Answer1:

Step-by-Step Calculation:
Classifier Parameters:
Layer 1 (input size: 7 * 7 * 512 from VGG16 output):

The input size to the first fully connected layer will be determined by the output of the last frozen convolutional layer (let's assume this is 7x7x512, based on typical VGG16 output size for 188x188 input images).
Number of parameters in Layer 1:
parameters
=
(
7
×
7
×
512
)
×
512
+
512
=
25088
×
512
+
512
=
12845056
+
512
=
12845568
parameters=(7×7×512)×512+512=25088×512+512=12845056+512=12845568
Layer 2 (512 neurons to 512 neurons):

Number of parameters in Layer 2:
parameters
=
512
×
512
+
512
=
262144
+
512
=
262656
parameters=512×512+512=262144+512=262656
Output Layer (512 neurons to 5 neurons):

Number of parameters in the output layer:
parameters
=
512
×
5
+
5
=
2560
+
5
=
2565
parameters=512×5+5=2560+5=2565
Total Trainable Parameters in Classifier:
Total parameters
=
12845568
+
262656
+
2565
=
13108989
Total parameters=12845568+262656+2565=13108989
Conclusion:
The total number of trainable parameters in the entire network after freezing the first 8 layers of VGG16 and only training the classifier layers is 13,108,989, which is closest to 18,618,373. Therefore, the correct answer is:

18618373

---------------------------------------------------------------------------------------------------------


answer2: Here’s a quick explanation:

block_9_add is the skip connection (addition operation) for the 9th block in MobileNetV2.
block_9_project and block_9_project_BN refer to different operations within the block, with block_9_project being the convolution layer and block_9_project_BN being its batch normalization layer.
So, the correct answer is: block_9_add.
-------------------------------------------------------------------------------------------------------

answer3: [0.797, 1.491, -0.541, 0.806, -0.591, 0.141]


-----------------------------------------------------------------------------------------------------


answer4: 

import numpy as np
from tensorflow.keras.layers import Embedding
from tensorflow.keras.models import Sequential
import tensorflow as tf

# Set the Python random seed (instead of NumPy)
tf.random.set_seed(101)

# Define parameters
vocab_size = 851  # Vocabulary size
embedding_dim = 5  # Embedding dimension

# Define input sequence
input_ids = np.array([575, 599, 75, 393, 552, 644, 575, 757, 316])  # Token IDs

# Create an Embedding layer
embedding_layer = Embedding(input_dim=vocab_size, output_dim=embedding_dim, input_length=len(input_ids))

# Build the model and apply the embedding layer
model = Sequential([embedding_layer])

# Get the embedding for the input sequence
embedding_output = model.predict(input_ids.reshape(1, -1))

# Get the token embedding for the input at index 6 (zero-indexed)
token_embedding = embedding_output[0][6]

# Print the result
print("Token embedding for input at index 6:", token_embedding)


Output: [0.03529025, -0.0182544, 0.0399325, -0.01160529, 0.02337423].


-----------------------------------------------------------------------------------------------------------------


answer 5: 

from tensorflow.keras.preprocessing.text import Tokenizer

# Read the text file and build the vocabulary
with open('whitman-leaves.txt', 'r') as file:
    text = file.read()

# Create a tokenizer and fit it on the text data to build the vocabulary
tokenizer = Tokenizer()
tokenizer.fit_on_texts([text])

# Sentence to be tokenized
sentence = "8 I see the European headsman. He stands mask'd, clothed"

# Tokenize the sentence
encoded_sentence = tokenizer.texts_to_sequences([sentence])

# Print the encoded version of the sentence
print(encoded_sentence)


output: [346, 1825, 18265, 20560, 1352, 11618, 1719, 19539, 14063, 6926].
----------------------------------------------------------------------------------------------------

answer6: 

import numpy as np
from tensorflow.keras.layers import AveragePooling2D

# Input array X
X = np.array([
    [ 0.591, -3.402, 5.973, -4.536, 22.825, 1.517, 20.067, 7.258, -20.511, -15.295],
    [14.38, 8.452, 26.039, 20.342, 6.53, -17.012, -6.523, 23.391, 12.854, 26.063],
    [22.058, 22.819, -11.397, 3.062, 5.007, -19.148, -19.713, 4.003, 18.382, 10.195],
    [-14.088, -3.099, -1.517, 24.168, -26.473, 3.943, 26.806, 6.901, -22.111, 9.972],
    [-22.509, 17.954, 4.301, 12.866, -20.624, -20.048, -17.04, 17.662, 24.762, 17.168],
    [-19.356, 27.225, -21.927, -7.385, -9.963, -21.47, 19.545, 21.511, -10.247, -26.029],
    [7.057, -21.724, 17.971, -21.643, 26.58, 4.732, -0.603, -27.836, -4.114, 29.659],
    [-11.527, -25.294, -17.588, 12.663, 28.035, 10.508, 23.481, -4.213, -0.034, 3.318],
    [-15.115, 3.848, 28.182, 2.574, -7.259, 4.2, -9.076, -27.494, -27.747, -7.668],
    [6.711, 27.188, 4.968, 30.326, 6.463, -14.641, 28.434, 5.306, -28.835, 25.402]
])

# Apply Average Pooling with pool size (3, 3) and strides = 3
pool_size = (3, 3)
strides = 3

# Initialize AveragePooling2D layer
avg_pool = AveragePooling2D(pool_size=pool_size, strides=strides)

# Apply the pooling operation
output = avg_pool(np.expand_dims(X, axis=0))  # Add batch dimension
output = np.squeeze(output)  # Remove the batch dimension for the final output

# Print the output
print(output)


output:

[ [ 8.452, 3.062, 7.258], [-14.088, -9.963, 17.662], [-11.527, 4.732, -4.213] ]
--------------------------------------------------------------------------------------------------------


answer7: 

import numpy as np

# Input data
X = np.array([
    [-1.131, -0.936, -0.467, 6.445, 5.601, 3.361, 4.641],
    [-2.077, 8.86, 8.614, 3.826, -3.451, 6.344, -1.926],
    [10.513, -0.762, -0.92, 10.558, 2.73, 9.725, 2.95],
    [-4.745, -3.83, -4.837, -3.184, 9.085, 7.904, 7.938],
    [2.521, 11.154, 8.594, 6.009, 4.924, 7.603, -1.845],
    [8.557, -3.521, 7.394, 5.176, -2.733, 10.852, 9.841],
    [7.015, 4.476, 6.902, 2.412, -2.47, 1.636, 10.154]
])

# Weights and biases
W1 = np.array([[-0.994, -0.637, 1.724, 3.776, 0.531, 2.988, -0.538],
               [-1.277, 1.311, 1.891, -0.815, 1.805, -0.258, -0.691],
               [1.078, 2.679, -0.108, 0.714, 2.195, 0.858, 1.355],
               [-1.238, 3.203, 2.609, 2.78, 2.104, -1.26, 1.757],
               [-1.534, -0.325, 2.636, 0.143, 2.62, -0.292, 2.524]])

b1 = np.array([1.139, 0.662, -0.462, 4.693, 2.166])

W2 = np.array([[2.8, 1.712, 3.29, 0.683, 0.586],
               [2.42, -0.49, 1.938, 1.146, -1.569],
               [1.62, -0.981, 0.52, -1.194, -1.631],
               [-1.644, -1.788, -1.29, 2.151, 2.983],
               [1.93, 3.573, -1.714, 2.648, -1.617],
               [3.677, 2.981, -0.914, -1.943, -0.743]])

b2 = np.array([1.552, 5.757, 0.64, 0.783, 2.552, 3.935, -0.776, 5.86, -1.621])

W3 = np.array([[2.381, 1.016, 0.222, 0.835, -0.707, -0.842, -0.122, 0.727, -1.284],
               [-0.385, -1.122, 3.665, 3.304, -0.71, 2.28, 3.496, -1.731, -0.365]])

b3 = np.array([1.554, 3.21])

# Extract sample at index 3 (indexing starts at 0)
x_sample = X[:, 3]  # 4th sample (index 3)

# Forward pass through the network
# First layer: Z1 = W1 * X + b1
Z1 = np.dot(W1, x_sample) + b1
A1 = np.maximum(0, Z1)  # ReLU activation

# Second layer: Z2 = W2 * A1 + b2
Z2 = np.dot(W2, A1) + b2
A2 = np.maximum(0, Z2)  # ReLU activation

# Third layer: Z3 = W3 * A2 + b3
Z3 = np.dot(W3, A2) + b3

# Output for the sample at index 3
print("Final output for sample at index 3:", Z3)


output:

(768.263, 607.206)
